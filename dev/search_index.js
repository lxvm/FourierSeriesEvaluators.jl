var documenterSearchIndex = {"docs":
[{"location":"methods/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"methods/","page":"Manual","title":"Manual","text":"Modules = [FourierSeriesEvaluators]\nOrder   = [:type, :function]","category":"page"},{"location":"methods/#FourierSeriesEvaluators.AbstractFourierSeries","page":"Manual","title":"FourierSeriesEvaluators.AbstractFourierSeries","text":"AbstractFourierSeries{N,T,iip}\n\nA supertype for multidimensional Fourier series objects. Given f::AbstractFourierSeries, you can evaluate at a point x with f(x), where x is a vector (or scalar if f is 1d).\n\nFourier series are periodic maps T^N to V where T is a real number and V is any vector space. Typically, a Fourier series can be represented by N-dimensional arrays whose elements belong to the vector space. If iip is true, then V is assumed to have mutable elements and inplace array operations are used. Otherwise, V is assumed to be immutable. The period of the series should be specified by values of type T, although no restriction is placed on the inputs to the series, e.g. arguments of type Complex{T} are OK. Additionally, if the caller wants to determine the floating-point precision of the Fourier coefficients, T and the arguments must both have that precision.\n\n\n\n\n\n","category":"type"},{"location":"methods/#FourierSeriesEvaluators.DerivativeSeries-Union{Tuple{AbstractFourierSeries}, Tuple{O}} where O","page":"Manual","title":"FourierSeriesEvaluators.DerivativeSeries","text":"DerivativeSeries{O}(f::FourierSeries)\n\nConstruct an evaluator of a Fourier series and all of its derivatives up to order O, which must be a positive integer. O=1 gives the gradient, O=2 gives the Hessian, and so on. The derivatives are returned in order as a tuple (f(x), df(x), d2f(x), ..., dOf(x)) where the entry of order O is given by:\n\nO=0: f\nO=1: (dfdx1, ..., dfdxN)\nO=2: ((d2fdx1dx1, ..., d2fdx1dxN), ..., (d2fdxNdxN,))\nO=3: (((d3fdx1dx1dx1, ..., d3fdx1dx1dxN), ..., (d3fdx1dxNdxN,)), ..., ((d3fdxNdxNdxN,),))\n\nand so on. The fewest number of contractions are made to compute all derivatives. As can be seen from the pattern above, the O-th derivative with partial derivatives i = [a_1 ≤ ... ≤ a_N] is stored in ds(x)[O+1][i[1]][i[2]]...[i[N]]. These indices are given by the simplical generalization of triangular numbers. For examples of how to index into the solution see the unit tests.\n\n\n\n\n\n","category":"method"},{"location":"methods/#FourierSeriesEvaluators.FourierSeries","page":"Manual","title":"FourierSeriesEvaluators.FourierSeries","text":"FourierSeries(coeffs::AbstractArray, [N]; period=2pi, offset=0, deriv=0, shift=0)\n\nConstruct a Fourier series whose coefficients are given by the coefficient array array coeffs whose elements should support addition and scalar multiplication, This type represents the Fourier series\n\nf(vecx) = sum_vecn in mathcal I C_vecn exp(i2piveck_vecncdotoverrightarrowx)\n\nThe indices vecn are the CartesianIndices of coeffs. Also, the keywords, which can either be a single value applied to all dimensions or a collection describing each dimension mean\n\nperiod: The periodicity of the Fourier series. Equivalent to 2pik\noffset: An offset in the phase index, which must be integer\nderiv: The degree of differentiation, implemented as a Fourier multiplier\nshift: A translation q such that the evaluation point x is shifted to x-q\n\nIf the optional argument N is set, it fixes the number of variables of the Fourier series, which may be less than or equal to ndims(coeffs), and the series is evaluated inplace.\n\n\n\n\n\n","category":"type"},{"location":"methods/#FourierSeriesEvaluators.FourierWorkspace","page":"Manual","title":"FourierSeriesEvaluators.FourierWorkspace","text":"FourierWorkspace\n\nA workspace for storing the intermediate arrays used during Fourier series evaluations. All functionality is provided by the workspace_allocate, workspace_contract!, and workspace_evaluate routines.\n\n\n\n\n\n","category":"type"},{"location":"methods/#FourierSeriesEvaluators.ManyFourierSeries","page":"Manual","title":"FourierSeriesEvaluators.ManyFourierSeries","text":"ManyFourierSeries(fs::AbstractFourierSeries{N,T,iip}...; period) where {N,T,iip}\n\nRepresents a tuple of Fourier series of the same dimension and contracts them all simultaneously. All the series are required to be either inplace or not.\n\n\n\n\n\n","category":"type"},{"location":"methods/#FourierSeriesEvaluators.allocate","page":"Manual","title":"FourierSeriesEvaluators.allocate","text":"allocate(f::AbstractFourierSeries{N}, x, ::Val{d}) where {N,d}\n\nReturn a cache that can be used by fourier_contract! to store the result of contracting the coefficients of f along axis d using an input x.\n\n\n\n\n\n","category":"function"},{"location":"methods/#FourierSeriesEvaluators.cis_inv-Tuple{Real}","page":"Manual","title":"FourierSeriesEvaluators.cis_inv","text":"Return cis and its inverse\n\n\n\n\n\n","category":"method"},{"location":"methods/#FourierSeriesEvaluators.contract!","page":"Manual","title":"FourierSeriesEvaluators.contract!","text":"contract!(cache, f::AbstractFourierSeries{N}, x, ::Val{d}) where {N,d}\n\nReturn another Fourier series of dimension N-1 by summing over dimension d of f with the phase factors evaluated at x and using the storage in cache created by a call to fourier_allocate\n\n\n\n\n\n","category":"function"},{"location":"methods/#FourierSeriesEvaluators.evaluate!","page":"Manual","title":"FourierSeriesEvaluators.evaluate!","text":"evaluate!(cache, f::AbstractFourierSeries{1}, x)\n\nEvaluate the Fourier series at the point x, optionally with cache for inplace evaluation created by a call to fourier_allocate\n\n\n\n\n\n","category":"function"},{"location":"methods/#FourierSeriesEvaluators.fourier_allocate-Union{Tuple{dim}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any, Any, Any, Val{dim}}} where {T, N, dim}","page":"Manual","title":"FourierSeriesEvaluators.fourier_allocate","text":"fourier_allocate(C, x, k, a, ::Val{dim})\n\nAllocate an array of the correct type for contracting the Fourier series along axis dim.\n\n\n\n\n\n","category":"method"},{"location":"methods/#FourierSeriesEvaluators.fourier_contract!-Union{Tuple{dim}, Tuple{N_}, Tuple{N}, Tuple{T}, Tuple{R}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer, Val{dim}}} where {R, T, N, N_, dim}","page":"Manual","title":"FourierSeriesEvaluators.fourier_contract!","text":"fourier_contract!(r::AbstractArray{T,N-1}, C::AbstractArray{T,N}, x, [k=1, a=0, shift=0, dim=Val(N)]) where {T,N}\n\nContract dimension dim of array C and write it to the array r, whose axes must match C's (excluding dimension dim). This function uses the indices in axes(C,N) to evaluate the phase factors, which makes it compatible with OffsetArrays as inputs. Optionally, a shift can be provided to manually offset the indices. Also, a represents the order of derivative of the series and must be a Number. The formula for what this routine calculates is:\n\nr_i_1dotsi_N-1 = sum_i_Nintextaxes(CN) C_i_1dotsi_N-1i_N+m+1 (ik (i_N + textshift))^a exp(ik x (i_N + textshift))\n\n\n\n\n\n","category":"method"},{"location":"methods/#FourierSeriesEvaluators.fourier_contract-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}, Tuple{AbstractArray{T, N}, Any, Any}, Tuple{AbstractArray{T, N}, Any, Any, Any}, Tuple{AbstractArray{T, N}, Any, Any, Any, Any}, Tuple{AbstractArray{T, N}, Any, Any, Any, Any, Any}} where {T, N}","page":"Manual","title":"FourierSeriesEvaluators.fourier_contract","text":"fourier_contract(C::Vector, x, [k=1, a=0, shift=0, dim=Val(N)])\n\nIdentical to fourier_contract! except that it allocates its output.\n\n\n\n\n\n","category":"method"},{"location":"methods/#FourierSeriesEvaluators.fourier_evaluate-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Integer, N}}}} where {T, N}","page":"Manual","title":"FourierSeriesEvaluators.fourier_evaluate","text":"fourier_evaluate(C::AbstractArray{T,N}, x::NTuple{N}, [k=1, a=0, shift=0]) where {T,N}\n\nEvaluates a N-D Fourier series C. This function uses the indices in axes(C) to evaluate the phase factors, which makes it compatible with OffsetArrays as inputs. Optionally, a shift can be provided to manually offset the indices. Also, a represents the order of derivative of the series and must be a Number. The arguments x, k, a, shift must all be tuples of length N, the same as the array dimension. The 1-D formula for what this routine calculates is:\n\nr = sum_i_intextaxes(C1) C_i (ik (i + textshift))^a exp(ik x (i + textshift))\n\nnote: Multi-dimensional performance hit\nThis routine is allocation-free, but using it for multidimensional evaluation can be slower than allocating because it always computes the Fourier coefficients on the fly. Thus, it is typically more efficient to compute the outermost dimensions of the series with fourier_contract! and then use this routine for the innermost dimension, which is faster because it doesn't use inplace operations. FourierSeries implements this behavior.\n\n\n\n\n\n","category":"method"},{"location":"methods/#FourierSeriesEvaluators.frequency","page":"Manual","title":"FourierSeriesEvaluators.frequency","text":"frequency(f::AbstractFourierSeries, [dim]) = map(inv, period(f, [dim]))\n\nReturn a tuple containing the frequency, or inverse of the period, of f. Optionally you can specify a dimension to just get the frequency of that dimension.\n\n\n\n\n\n","category":"function"},{"location":"methods/#FourierSeriesEvaluators.period","page":"Manual","title":"FourierSeriesEvaluators.period","text":"period(f::AbstractFourierSeries, [dim])\n\nReturn a tuple containing the periodicity of f. Optionally you can specify a dimension to just get the period of that dimension. This should have the floating-point precision of the input used for the Fourier series evaluation.\n\n\n\n\n\n","category":"function"},{"location":"methods/#FourierSeriesEvaluators.workspace_allocate-Union{Tuple{N}, Tuple{AbstractFourierSeries{N, T, iip} where {T, iip}, Tuple{Vararg{Any, N}}}, Tuple{AbstractFourierSeries{N, T, iip} where {T, iip}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Integer, N}}}} where N","page":"Manual","title":"FourierSeriesEvaluators.workspace_allocate","text":"workspace_allocate(s::AbstractFourierSeries{N}, x::NTuple{N}, [len::NTuple{N}=ntuple(one,N)])\n\nAllocates a FourierWorkspace for the Fourier series s that can be used to evaluate the series multiple times without allocating on-the-fly. The len argument can indicate how many copies of workspace should be made for each variable for downstream use in parallel workloads.\n\nThe workspace is constructed recursively starting from the outer dimension and moving towards the inner dimension so as to access memory contiguously. Thus, the outer dimension has len[N] workspace copies and each of these has len[N-1] workspaces for the next variable. In total there are prod(len) leaf-level caches to use for parallel workloads.\n\n\n\n\n\n","category":"method"},{"location":"methods/#FourierSeriesEvaluators.workspace_contract!","page":"Manual","title":"FourierSeriesEvaluators.workspace_contract!","text":"workspace_contract!(ws, x, [i=1])\n\nReturns a workspace with the series contracted at variable x in the outer dimension. The index i selects which workspace in the cache to assign the new data.\n\n\n\n\n\n","category":"function"},{"location":"methods/#FourierSeriesEvaluators.workspace_evaluate!","page":"Manual","title":"FourierSeriesEvaluators.workspace_evaluate!","text":"workspace_evaluate!(ws, x, [i=1])\n\nReturn the 1-d series evaluated at the variable x, using cache sector i.\n\n\n\n\n\n","category":"function"},{"location":"methods/#FourierSeriesEvaluators.workspace_evaluate-Tuple{FourierWorkspace{var\"#s25\", C} where {var\"#s25\"<:(AbstractFourierSeries{1, T, iip} where {T, iip}), C}, Tuple{Any}}","page":"Manual","title":"FourierSeriesEvaluators.workspace_evaluate","text":"workspace_evaluate(ws, x)\n\nEvaluates the series using the workspace.\n\n\n\n\n\n","category":"method"},{"location":"#FourierSeriesEvaluators.jl","page":"Home","title":"FourierSeriesEvaluators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FourierSeriesEvaluators","category":"page"},{"location":"#FourierSeriesEvaluators","page":"Home","title":"FourierSeriesEvaluators","text":"A package implementing fast, multi-dimensional Fourier series evaluators that are more convenient than FFTs when using hierarchical grids and the number of coefficients is small compared to the number of evaluation points.\n\nFor example, to evaluate cosine\n\nFourierSeries([0.5, 0.0, 0.5], period=2pi, offset=-2)(pi) ≈ cos(pi)\n\nor to evaluate sine from the derivative of cosine\n\nFourierSeries([0.5, 0.0, 0.5], period=2pi, offset=-2, deriv=1)(pi/2) ≈ -sin(pi/2)\n\nThe package also provides the following low-level routines that are also useful\n\nfourier_contract: contracts 1 index of a multidimensional Fourier series\nfourier_evaluate: evaluates 1d Fourier series\n\nThese routines have the following features\n\nSupport for abstract (esp. offset) arrays\nSupport for evaluation in the complex plane\nEvaluation of derivatives of the Fourier series with Fourier multipliers\n\n\n\n\n\n","category":"module"}]
}
