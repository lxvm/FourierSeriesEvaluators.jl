var documenterSearchIndex = {"docs":
[{"location":"interface/#AbstractFourierSeries-interface","page":"AbstractFourierSeries","title":"AbstractFourierSeries interface","text":"","category":"section"},{"location":"interface/","page":"AbstractFourierSeries","title":"AbstractFourierSeries","text":"When defining subtypes of AbstractFourierSeries, the following interface needs to be implemented.","category":"page"},{"location":"interface/","page":"AbstractFourierSeries","title":"AbstractFourierSeries","text":"Modules = [FourierSeriesEvaluators]\nOrder   = [:type, :function]\nPages   = [\"definitions.jl\"]","category":"page"},{"location":"interface/#FourierSeriesEvaluators.AbstractFourierSeries","page":"AbstractFourierSeries","title":"FourierSeriesEvaluators.AbstractFourierSeries","text":"AbstractFourierSeries{N,T,iip}\n\nA supertype for multidimensional Fourier series objects. Given a f::AbstractFourierSeries, you can evaluate it at a point x with f(x), where x is a vector (or scalar if f is 1d).\n\nFourier series are periodic maps T^N to V where T is a space of real numbers and V is any vector space. Typically, a Fourier series can be represented by N-dimensional arrays whose elements belong to the vector space. If iip is true, then V is assumed to have mutable elements and inplace array operations are used. Otherwise, V is assumed to be immutable. The period of the series should be specified by values of type T, although no restriction is placed on the inputs to the series, e.g. arguments of type Complex{T} are OK. Additionally, if the caller wants to determine the floating-point precision of the Fourier coefficients, T and the arguments must both have that precision.\n\n\n\n\n\n","category":"type"},{"location":"interface/#FourierSeriesEvaluators.allocate","page":"AbstractFourierSeries","title":"FourierSeriesEvaluators.allocate","text":"allocate(f::AbstractFourierSeries{N}, x, ::Val{d}) where {N,d}\n\nReturn a cache that can be used by contract! to store the result of contracting the coefficients of f along axis d using an input x.\n\n\n\n\n\n","category":"function"},{"location":"interface/#FourierSeriesEvaluators.contract!","page":"AbstractFourierSeries","title":"FourierSeriesEvaluators.contract!","text":"contract!(cache, f::AbstractFourierSeries{N}, x, ::Val{d}) where {N,d}\n\nReturn another Fourier series of dimension N-1 by summing over dimension d of f with the phase factors evaluated at x and using the storage in cache created by a call to allocate\n\n\n\n\n\n","category":"function"},{"location":"interface/#FourierSeriesEvaluators.evaluate!","page":"AbstractFourierSeries","title":"FourierSeriesEvaluators.evaluate!","text":"evaluate!(cache, f::AbstractFourierSeries{1}, x)\n\nEvaluate the Fourier series at the point x using a cache for inplace evaluation created by a call to allocate. If the series is inplace, the cache storage may be used as the return value, and if the series is not inplace the cache may be unused.\n\n\n\n\n\n","category":"function"},{"location":"interface/#FourierSeriesEvaluators.frequency","page":"AbstractFourierSeries","title":"FourierSeriesEvaluators.frequency","text":"frequency(f::AbstractFourierSeries, [dim]) == map(inv, period(f, [dim]))\n\nReturn a tuple containing the frequency, or inverse of the period, of f. Optionally you can specify a dimension to just get the frequency of that dimension.\n\n\n\n\n\n","category":"function"},{"location":"interface/#FourierSeriesEvaluators.nextderivative","page":"AbstractFourierSeries","title":"FourierSeriesEvaluators.nextderivative","text":"nextderivative(f::AbstractFourierSeries, ::Val{d}) where {d}\n\nThis method returns a new series that evaluates the derivative of f with respect to its dth variable. This method is optional for normal evaluation, but DerivativeSeries requires it.\n\n\n\n\n\n","category":"function"},{"location":"interface/#FourierSeriesEvaluators.period","page":"AbstractFourierSeries","title":"FourierSeriesEvaluators.period","text":"period(f::AbstractFourierSeries, [dim])\n\nReturn a tuple containing the periodicity of f. Optionally you can specify a dimension to just get the period of that dimension. This should have the floating-point precision of the input used for the Fourier series evaluation.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following are several examples of how to use the Fourier series evaluators exported by FourierSeriesEvaluators together with their documentation.","category":"page"},{"location":"examples/#[FourierSeries](@ref)","page":"Examples","title":"FourierSeries","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The FourierSeries constructor accepts an array of coefficients and a mandatory keyword argument, period. To create a 3-dimensional series with random coefficients we can use the following","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f = FourierSeries(rand(4,4,4), period=1.0)\n4×4×4 and (1.0, 1.0, 1.0)-periodic FourierSeries with Float64 coefficients, (0, 0, 0) derivative, (0, 0, 0) offset","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can then evaluate f at a random point using its function-like interface f(rand(3)).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To control the indices of the coefficients, which determine the phase factors according to a formula given later, we can either use arrays with offset indices, or provide the offsets ourselves","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using OffsetArrays\n\njulia> c = OffsetVector(rand(7), -3:3);\n\njulia> x = rand();\n\njulia> FourierSeries(c, period=1)(x) == FourierSeries(parent(c), period=1, offset=-4)(x)\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If we want to take the derivative of a Fourier series such as the derivative of sine, which is cosine, we can first construct and validate our version of sin","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> sine = FourierSeries([-1, 0, 1]/2im, period=2pi, offset=-2)\n3-element and (6.283185307179586,)-periodic FourierSeries with ComplexF64 coefficients, (0,) derivative, (-2,) offset\n\njulia> x = rand();\n\njulia> sine(x) ≈ sin(x)\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"and then reuse the arguments to the series and provide the order of derivative with the deriv keyword, which is typically integer but can even be fractional","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> cosine = FourierSeries([-1, 0, 1]/2im, period=2pi, offset=-2, deriv=1)\n3-element and (6.283185307179586,)-periodic FourierSeries with ComplexF64 coefficients, (1,) derivative, (-2,) offset\n\njulia> cosine(x) ≈ cos(x)\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For multidimensional series, a scalar value of deriv means it is applied to derivatives of all variables, whereas a tuple or vector of orders will select the order of derivative applied to each variable. For automatically generating all orders of derivatives see the section on DerivativeSeries.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Lastly, if we wish to evaluate multiple Fourier series at the same time, we may either use array-valued coefficients, such as with StaticArrays.jl, or for very large arrays we may pass a second positional argument to FourierSeries to provide the number of variables in the FourierSeries corresponding to the outermost axes of the coefficient array. Below we have an example constructing equivalent evaluators using both styles.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> c = rand(5,7);\n\njulia> using StaticArrays\n\njulia> sc = reinterpret(reshape, SVector{5,eltype(c)}, c);\n\njulia> x = rand();\n\njulia> FourierSeries(sc, period=1.0)(x) ≈ FourierSeries(c, 1, period=1.0)(x)\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"When using the form with the positional argument, note that inplace array operations are used to avoid allocations, so be careful not to overwrite the result if reusing it.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"FourierSeriesEvaluators.FourierSeries","category":"page"},{"location":"examples/#FourierSeriesEvaluators.FourierSeries","page":"Examples","title":"FourierSeriesEvaluators.FourierSeries","text":"FourierSeries(coeffs::AbstractArray, [N]; period, offset=0, deriv=0)\n\nConstruct a Fourier series whose coefficients are given by the coefficient array array coeffs whose elements should support addition and scalar multiplication, This object represents the Fourier series\n\nf(vecx) = sum_vecn in mathcal I C_vecn left( prod_i left( 2pi f_i (n_i + o_i) sqrt-1 right)^a_i expleft(2pi f_i x_i (n_i + o_i) sqrt-1 right) right)\n\nHere, the indices mathcal I are the CartesianIndices of coeffs, f_i = 1t_i is the frequency/inverse period, a_i is the order of derivative, and o_i is the index offset. Also, the keywords, which can either be a single value applied to all dimensions or a tuple/vector describing each dimension mean\n\nperiod: The periodicity of the Fourier series, which must be a real number\noffset: An offset in the phase index, which must be integer\nderiv: The degree of differentiation, implemented as a Fourier multiplier. Can be any number a such that x^a is well-defined, or a Val(a). a::Integer performs best.\n\nIf inplace evaluation or evaluation of multiple series is desired, the optional argument N when set fixes the number of variables of the Fourier series, which may be less than or equal to ndims(coeffs), and the series is evaluated inplace, returning the innermost, continguous ndims(coeffs)-N axes evaluated at the variables corresponding to the remaining outer axes.\n\n\n\n\n\n","category":"type"},{"location":"examples/#[ManyFourierSeries](@ref)","page":"Examples","title":"ManyFourierSeries","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A third way to evaluate multiple series at the same time, possibly with different types of coefficients, is with a ManyFourierSeries, which behaves like a tuple of FourierSeries. We can construct one from multiple series and a period (which the element series are rescaled by so that all periods match).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f1 = FourierSeries(rand(3,3), period=3);\n\njulia> f2 = FourierSeries(rand(3,3), period=2);\n\njulia> x = rand(2);\n\njulia> ms = ManyFourierSeries(f1, f2, period=1)\n2-dimensional and (1, 1)-periodic ManyFourierSeries with 2 series\n\njulia> ms(x)[1] == f1(3x)\ntrue\n\njulia> ms(x)[2] == f2(2x)\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are situations in which inplace FourierSeries may be more efficient than ManyFourierSeries, since the former calculates phase factors fewer times than the later. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"FourierSeriesEvaluators.ManyFourierSeries","category":"page"},{"location":"examples/#FourierSeriesEvaluators.ManyFourierSeries","page":"Examples","title":"FourierSeriesEvaluators.ManyFourierSeries","text":"ManyFourierSeries(fs::AbstractFourierSeries{N,T,iip}...; period) where {N,T,iip}\n\nRepresents a tuple of Fourier series of the same dimension and contracts them all simultaneously. All the series are required to be either inplace or not.\n\n\n\n\n\n","category":"type"},{"location":"examples/#[DerivativeSeries](@ref)","page":"Examples","title":"DerivativeSeries","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To systematically compute all orders of derivatives of a Fourier series, we can wrap a series with a DerivativeSeries{O}, where O::Integer specifies the order of derivative to evaluate athe series and take all of its derivatives up to and including degree O.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> sine = FourierSeries([-1, 0, 1]/2im, period=2pi, offset=-2)\n3-element and (6.283185307179586,)-periodic FourierSeries with ComplexF64 coefficients, (0,) derivative, (-2,) offset\n\njulia> ds = DerivativeSeries{1}(sine)\n1-dimensional and (6.283185307179586,)-periodic DerivativeSeries of order 1\n\njulia> ds(0)\n(0.0 + 0.0im, (1.0 + 0.0im,))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can use this to show that the fourth derivative of sine is itself","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> d4s = DerivativeSeries{4}(sine)\n1-dimensional and (6.283185307179586,)-periodic DerivativeSeries of order 4\n\njulia> d4s(pi/3)\n(0.8660254037844386 + 0.0im, (0.5000000000000001 + 0.0im,), ((-0.8660254037844386 + 0.0im,),), (((-0.5000000000000001 + 0.0im,),),), ((((0.8660254037844386 + 0.0im,),),),))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"When applied to multidimensional series, all mixed partial derivatives are computed exactly once and their layout in the tuple of results is explained below.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"FourierSeriesEvaluators.DerivativeSeries\nFourierSeriesEvaluators.JacobianSeries\nFourierSeriesEvaluators.HessianSeries","category":"page"},{"location":"examples/#FourierSeriesEvaluators.DerivativeSeries","page":"Examples","title":"FourierSeriesEvaluators.DerivativeSeries","text":"DerivativeSeries{O}(f::AbstractFourierSeries)\n\nConstruct an evaluator of a Fourier series and all of its derivatives up to order O, which must be a positive integer. O=1 gives the gradient, O=2 gives the Hessian, and so on. The derivatives are returned in order as a tuple (f(x), df(x), d2f(x), ..., dOf(x)) where the entry of order O is given by:\n\nO=0: f\nO=1: (dfdx1, ..., dfdxN)\nO=2: ((d2fdx1dx1, ..., d2fdx1dxN), ..., (d2fdxNdxN,))\nO=3: (((d3fdx1dx1dx1, ..., d3fdx1dx1dxN), ..., (d3fdx1dxNdxN,)), ..., ((d3fdxNdxNdxN,),))\n\nand so on. The fewest number of contractions are made to compute all derivatives. As can be seen from the pattern above, the O-th derivative with partial derivatives i = [a_1 ≤ ... ≤ a_N] is stored in ds(x)[O+1][i[1]][i[2]]...[i[N]]. These indices are given by the simplical generalization of triangular numbers. For examples of how to index into the solution see the unit tests.\n\nFor this routine to work, f must implement nextderivative.\n\n\n\n\n\n","category":"type"},{"location":"examples/#FourierSeriesEvaluators.JacobianSeries","page":"Examples","title":"FourierSeriesEvaluators.JacobianSeries","text":"JacobianSeries\n\nAlias for a DerivativeSeries of order 1\n\n\n\n\n\n","category":"type"},{"location":"examples/#FourierSeriesEvaluators.HessianSeries","page":"Examples","title":"FourierSeriesEvaluators.HessianSeries","text":"HessianSeries\n\nAlias for a DerivativeSeries of order 2\n\n\n\n\n\n","category":"type"},{"location":"examples/#[FourierWorkspace](@ref)","page":"Examples","title":"FourierWorkspace","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"By default, evaluating a Fourier series using the function-like interface allocates several intermediate arrays in order to achieve the fastest-possible evaluation with as few as possible calculations of phase factors. These arrays can be preallocated in a FourierWorkspace","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> s = FourierSeries(rand(17,17,17), period=1)\n17×17×17 and (1, 1, 1)-periodic FourierSeries with Float64 coefficients, (0, 0, 0) derivative, (0, 0, 0) offset\n\njulia> ws = FourierSeriesEvaluators.workspace_allocate(s, Tuple(x));\n\njulia> @time s(x);\n  0.000044 seconds (3 allocations: 5.047 KiB)\n\njulia> @time ws(x);\n  0.000063 seconds (1 allocation: 32 bytes)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also allocate nested workspaces that can be used independently to evaluate the same series at many points in a hierarchical or product grid in parallel workloads.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> ws3 = FourierSeriesEvaluators.workspace_allocate(s, Tuple(x), (2,2,2));\n\njulia> ws2 = FourierSeriesEvaluators.workspace_contract!(ws3, x[3], 1);\n\njulia> ws1 = FourierSeriesEvaluators.workspace_contract!(ws2, x[2], 2);\n\njulia> FourierSeriesEvaluators.workspace_evaluate!(ws1, x[1], 1) == s(x)\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that the 3rd argument of workspace_allocate, workspace_contract!, and workspace_evaluate! either specifies the number of nested workspaces to create or selects the workspace to use.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Modules = [FourierSeriesEvaluators]\nOrder   = [:type, :function]\nPages   = [\"workspace.jl\"]","category":"page"},{"location":"examples/#FourierSeriesEvaluators.FourierWorkspace","page":"Examples","title":"FourierSeriesEvaluators.FourierWorkspace","text":"FourierWorkspace\n\nA workspace for storing a Fourier series and the intermediate arrays used for evaluations. Given a ws::FourierWorkspace, you can evaluate it at a point x with ws(x).\n\nAll functionality is implemented by the workspace_allocate, workspace_contract!, and workspace_evaluate! routines, which allow multiple caches within each dimension of evaluation to enable parallel workloads.\n\n\n\n\n\n","category":"type"},{"location":"examples/#FourierSeriesEvaluators.workspace_allocate-Union{Tuple{N}, Tuple{AbstractFourierSeries{N, T, iip} where {T, iip}, Tuple{Vararg{Any, N}}}, Tuple{AbstractFourierSeries{N, T, iip} where {T, iip}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Integer, N}}}} where N","page":"Examples","title":"FourierSeriesEvaluators.workspace_allocate","text":"workspace_allocate(s::AbstractFourierSeries{N}, x::NTuple{N}, [len::NTuple{N}=ntuple(one,N)])\n\nAllocates a FourierWorkspace for the Fourier series s that can be used to evaluate the series multiple times without allocating on-the-fly. The len argument can indicate how many copies of workspace should be made for each variable for downstream use in parallel workloads.\n\nThe workspace is constructed recursively starting from the outer dimension and moving towards the inner dimension so as to access memory contiguously. Thus, the outer dimension has len[N] workspace copies and each of these has len[N-1] workspaces for the next variable. In total there are prod(len) leaf-level caches to use for parallel workloads.\n\n\n\n\n\n","category":"method"},{"location":"examples/#FourierSeriesEvaluators.workspace_contract!","page":"Examples","title":"FourierSeriesEvaluators.workspace_contract!","text":"workspace_contract!(ws, x, [i=1])\n\nReturns a workspace with the series contracted at variable x in the outer dimension. The index i selects which workspace in the cache to assign the new data.\n\n\n\n\n\n","category":"function"},{"location":"examples/#FourierSeriesEvaluators.workspace_evaluate!","page":"Examples","title":"FourierSeriesEvaluators.workspace_evaluate!","text":"workspace_evaluate!(ws, x, [i=1])\n\nReturn the 1-d series evaluated at the variable x, using cache sector i.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Function-reference","page":"Reference","title":"Function reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following functions are exported by the FourierSeriesEvaluators package","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [FourierSeriesEvaluators]\nPages   = [\"fourier_kernel.jl\"]","category":"page"},{"location":"reference/#FourierSeriesEvaluators.fourier_allocate-Union{Tuple{dim}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any, Any, Any, Val{dim}}} where {T, N, dim}","page":"Reference","title":"FourierSeriesEvaluators.fourier_allocate","text":"fourier_allocate(C, x, k, a, ::Val{dim})\n\nAllocate an array of the correct type for contracting the Fourier series along axis dim.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FourierSeriesEvaluators.fourier_contract!-Union{Tuple{dim}, Tuple{N_}, Tuple{N}, Tuple{T}, Tuple{R}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer, Val{dim}}} where {R, T, N, N_, dim}","page":"Reference","title":"FourierSeriesEvaluators.fourier_contract!","text":"fourier_contract!(r::AbstractArray{T,N-1}, C::AbstractArray{T,N}, x, [k=1, a=0, shift=0, dim=Val(N)]) where {T,N}\n\nContract dimension dim of array C and write it to the array r, whose axes must match C's (excluding dimension dim). This function uses the indices in axes(C,N) to evaluate the phase factors, which makes it compatible with OffsetArrays as inputs. Optionally, a shift can be provided to manually offset the indices. Also, a represents the order of derivative of the series and must be a Number. The formula for what this routine calculates is:\n\nr_i_1dotsi_N-1 = sum_i_Nintextaxes(CN) C_i_1dotsi_N-1i_N+m+1 (ik (i_N + textshift))^a exp(ik x (i_N + textshift))\n\n\n\n\n\n","category":"method"},{"location":"reference/#FourierSeriesEvaluators.fourier_contract-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}, Tuple{AbstractArray{T, N}, Any, Any}, Tuple{AbstractArray{T, N}, Any, Any, Any}, Tuple{AbstractArray{T, N}, Any, Any, Any, Any}, Tuple{AbstractArray{T, N}, Any, Any, Any, Any, Any}} where {T, N}","page":"Reference","title":"FourierSeriesEvaluators.fourier_contract","text":"fourier_contract(C::Vector, x, [k=1, a=0, shift=0, dim=Val(N)])\n\nIdentical to fourier_contract! except that it allocates its output.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FourierSeriesEvaluators.fourier_evaluate-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Integer, N}}}} where {T, N}","page":"Reference","title":"FourierSeriesEvaluators.fourier_evaluate","text":"fourier_evaluate(C::AbstractArray{T,N}, x::NTuple{N}, [k=1, a=0, shift=0]) where {T,N}\n\nEvaluates a N-D Fourier series C. This function uses the indices in axes(C) to evaluate the phase factors, which makes it compatible with OffsetArrays as inputs. Optionally, a shift can be provided to manually offset the indices. Also, a represents the order(s) of derivative of the series. The arguments x, k, a, shift must all be tuples of length N, the same as the array dimension. The 1-D formula for what this routine calculates is:\n\nr = sum_nintextaxes(C1) C_n (ik (n + textshift))^a exp(ik x (n + textshift))\n\nnote: Multi-dimensional performance hit\nThis routine is allocation-free, but using it for multidimensional evaluation can be slower than allocating because it always computes the Fourier coefficients on the fly. Thus, it is typically more efficient to compute the outermost dimensions of the series with fourier_contract! and then use this routine for the innermost dimension, which is faster because it doesn't use inplace operations. FourierSeries implements this behavior.\n\n\n\n\n\n","category":"method"},{"location":"#FourierSeriesEvaluators.jl","page":"Home","title":"FourierSeriesEvaluators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FourierSeriesEvaluators","category":"page"},{"location":"#FourierSeriesEvaluators","page":"Home","title":"FourierSeriesEvaluators","text":"A package implementing fast, multi-dimensional Fourier interpolation that is more convenient than FFTs when using hierarchical grids and when the number of coefficients is small compared to the number of evaluation points.\n\nQuickstart\n\nAs a first example, we evaluate cosine from its Fourier series coefficients:\n\njulia> using FourierSeriesEvaluators\n\njulia> cosine = FourierSeries([0.5, 0.0, 0.5], period=2pi, offset=-2)\n3-element and (6.283185307179586,)-periodic FourierSeries with Float64 coefficients, (0,) derivative, (-2,) offset\n\njulia> cosine(pi)\n-1.0 + 0.0im\n\nNotice that we can create a series object and interpolate with a function-like interface. For more examples, see the documentation.\n\nFeatures\n\nGeneric Fourier series can be implemented with the AbstractFourierSeries interface and the following implementations are provided as building blocks for others:\n\nFourierSeries: (inplace) evaluation at real/complex arguments\nManyFourierSeries: evaluation of multiple series\nDerivativeSeries: automatic evaluation of derivatives of series to any order\n\nAdditionally, memory management for parallel workloads is supported by FourierWorkspace.\n\nExtended help\n\nThe package also provides the following low-level routines that are also useful\n\nfourier_contract: contracts 1 variable of a multidimensional Fourier series\nfourier_evaluate: evaluates N-dimensional Fourier series with no allocations\n\nThese routines have the following features\n\nSupport for abstract (esp. offset) coefficient arrays and array-valued coefficients\nSupport for evaluation in the complex plane\nEvaluation of derivatives of the Fourier series with Fourier multipliers\n\n\n\n\n\n","category":"module"}]
}
