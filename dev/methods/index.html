<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · FourierSeriesEvaluators.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FourierSeriesEvaluators.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/main/docs/src/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.AbstractFourierSeries" href="#FourierSeriesEvaluators.AbstractFourierSeries"><code>FourierSeriesEvaluators.AbstractFourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFourierSeries{N,T,iip}</code></pre><p>A supertype for multidimensional Fourier series objects. Given <code>f::AbstractFourierSeries</code>, you can evaluate at a point <code>x</code> with <code>f(x)</code>, where <code>x</code> is a vector (or scalar if <code>f</code> is 1d).</p><p>Fourier series are periodic maps <span>$T^N \to V$</span> where <code>T</code> is a real number and <span>$V$</span> is any vector space. Typically, a Fourier series can be represented by <code>N</code>-dimensional arrays whose elements belong to the vector space. If <code>iip</code> is <code>true</code>, then <span>$V$</span> is assumed to have mutable elements and inplace array operations are used. Otherwise, <span>$V$</span> is assumed to be immutable. The period of the series should be specified by values of type <code>T</code>, although no restriction is placed on the inputs to the series, e.g. arguments of type <code>Complex{T}</code> are OK. Additionally, if the caller wants to determine the floating-point precision of the Fourier coefficients, <code>T</code> and the arguments must both have that precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/definitions.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.DerivativeSeries-Union{Tuple{AbstractFourierSeries}, Tuple{O}} where O" href="#FourierSeriesEvaluators.DerivativeSeries-Union{Tuple{AbstractFourierSeries}, Tuple{O}} where O"><code>FourierSeriesEvaluators.DerivativeSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DerivativeSeries{O}(f::FourierSeries)</code></pre><p>Construct an evaluator of a Fourier series and all of its derivatives up to order <code>O</code>, which must be a positive integer. <code>O=1</code> gives the gradient, <code>O=2</code> gives the Hessian, and so on. The derivatives are returned in order as a tuple <code>(f(x), df(x), d2f(x), ..., dOf(x))</code> where the entry of order <code>O</code> is given by:</p><ul><li><code>O=0</code>: <code>f</code></li><li><code>O=1</code>: <code>(dfdx1, ..., dfdxN)</code></li><li><code>O=2</code>: <code>((d2fdx1dx1, ..., d2fdx1dxN), ..., (d2fdxNdxN,))</code></li><li><code>O=3</code>: <code>(((d3fdx1dx1dx1, ..., d3fdx1dx1dxN), ..., (d3fdx1dxNdxN,)), ..., ((d3fdxNdxNdxN,),))</code></li></ul><p>and so on. The fewest number of contractions are made to compute all derivatives. As can be seen from the pattern above, the <code>O</code>-th derivative with partial derivatives <code>i = [a_1 ≤ ... ≤ a_N]</code> is stored in <code>ds(x)[O+1][i[1]][i[2]]...[i[N]]</code>. These indices are given by the simplical generalization of <a href="https://en.wikipedia.org/wiki/Triangular_number">triangular numbers</a>. For examples of how to index into the solution see the unit tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/fourier_series.jl#L164-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.FourierSeries" href="#FourierSeriesEvaluators.FourierSeries"><code>FourierSeriesEvaluators.FourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FourierSeries(coeffs::AbstractArray, [N]; period=2pi, offset=0, deriv=0, shift=0)</code></pre><p>Construct a Fourier series whose coefficients are given by the coefficient array array <code>coeffs</code> whose elements should support addition and scalar multiplication, This type represents the Fourier series</p><p class="math-container">\[f(\vec{x}) = \sum_{\vec{n} \in \mathcal I} C_{\vec{n}} \exp(i2\pi\vec{k}_{\vec{n}}\cdot\overrightarrow{x})\]</p><p>The indices <span>$\vec{n}$</span> are the <code>CartesianIndices</code> of <code>coeffs</code>. Also, the keywords, which can either be a single value applied to all dimensions or a collection describing each dimension mean</p><ul><li><code>period</code>: The periodicity of the Fourier series. Equivalent to <span>$2\pi/k$</span></li><li><code>offset</code>: An offset in the phase index, which must be integer</li><li><code>deriv</code>: The degree of differentiation, implemented as a Fourier multiplier</li><li><code>shift</code>: A translation <code>q</code> such that the evaluation point <code>x</code> is shifted to <code>x-q</code></li></ul><p>If the optional argument <code>N</code> is set, it fixes the number of variables of the Fourier series, which may be less than or equal to <code>ndims(coeffs)</code>, and the series is evaluated inplace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/fourier_series.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.FourierWorkspace" href="#FourierSeriesEvaluators.FourierWorkspace"><code>FourierSeriesEvaluators.FourierWorkspace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FourierWorkspace</code></pre><p>A workspace for storing the intermediate arrays used during Fourier series evaluations. All functionality is provided by the <a href="#FourierSeriesEvaluators.workspace_allocate-Union{Tuple{N}, Tuple{AbstractFourierSeries{N, T, iip} where {T, iip}, Tuple{Vararg{Any, N}}}, Tuple{AbstractFourierSeries{N, T, iip} where {T, iip}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Integer, N}}}} where N"><code>workspace_allocate</code></a>, <a href="#FourierSeriesEvaluators.workspace_contract!"><code>workspace_contract!</code></a>, and <a href="#FourierSeriesEvaluators.workspace_evaluate-Tuple{FourierWorkspace{var&quot;#s25&quot;, C} where {var&quot;#s25&quot;&lt;:(AbstractFourierSeries{1, T, iip} where {T, iip}), C}, Tuple{Any}}"><code>workspace_evaluate</code></a> routines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/workspace.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.ManyFourierSeries" href="#FourierSeriesEvaluators.ManyFourierSeries"><code>FourierSeriesEvaluators.ManyFourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManyFourierSeries(fs::AbstractFourierSeries{N,T,iip}...; period) where {N,T,iip}</code></pre><p>Represents a tuple of Fourier series of the same dimension and contracts them all simultaneously. All the series are required to be either inplace or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/fourier_series.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.allocate" href="#FourierSeriesEvaluators.allocate"><code>FourierSeriesEvaluators.allocate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allocate(f::AbstractFourierSeries{N}, x, ::Val{d}) where {N,d}</code></pre><p>Return a cache that can be used by <a href="#FourierSeriesEvaluators.fourier_contract!-Union{Tuple{dim}, Tuple{N_}, Tuple{N}, Tuple{T}, Tuple{R}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer, Val{dim}}} where {R, T, N, N_, dim}"><code>fourier_contract!</code></a> to store the result of contracting the coefficients of <code>f</code> along axis <code>d</code> using an input <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/definitions.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.cis_inv-Tuple{Real}" href="#FourierSeriesEvaluators.cis_inv-Tuple{Real}"><code>FourierSeriesEvaluators.cis_inv</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return cis and its inverse</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/fourier_kernel.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.contract!" href="#FourierSeriesEvaluators.contract!"><code>FourierSeriesEvaluators.contract!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contract!(cache, f::AbstractFourierSeries{N}, x, ::Val{d}) where {N,d}</code></pre><p>Return another Fourier series of dimension <code>N-1</code> by summing over dimension <code>d</code> of <code>f</code> with the phase factors evaluated at <code>x</code> and using the storage in <code>cache</code> created by a call to <a href="#FourierSeriesEvaluators.fourier_allocate-Union{Tuple{dim}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any, Any, Any, Val{dim}}} where {T, N, dim}"><code>fourier_allocate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/definitions.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.evaluate!" href="#FourierSeriesEvaluators.evaluate!"><code>FourierSeriesEvaluators.evaluate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate!(cache, f::AbstractFourierSeries{1}, x)</code></pre><p>Evaluate the Fourier series at the point <code>x</code>, optionally with <code>cache</code> for inplace evaluation created by a call to <a href="#FourierSeriesEvaluators.fourier_allocate-Union{Tuple{dim}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any, Any, Any, Val{dim}}} where {T, N, dim}"><code>fourier_allocate</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/definitions.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.fourier_allocate-Union{Tuple{dim}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any, Any, Any, Val{dim}}} where {T, N, dim}" href="#FourierSeriesEvaluators.fourier_allocate-Union{Tuple{dim}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any, Any, Any, Val{dim}}} where {T, N, dim}"><code>FourierSeriesEvaluators.fourier_allocate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fourier_allocate(C, x, k, a, ::Val{dim})</code></pre><p>Allocate an array of the correct type for contracting the Fourier series along axis <code>dim</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/fourier_kernel.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.fourier_contract!-Union{Tuple{dim}, Tuple{N_}, Tuple{N}, Tuple{T}, Tuple{R}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer, Val{dim}}} where {R, T, N, N_, dim}" href="#FourierSeriesEvaluators.fourier_contract!-Union{Tuple{dim}, Tuple{N_}, Tuple{N}, Tuple{T}, Tuple{R}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer, Val{dim}}} where {R, T, N, N_, dim}"><code>FourierSeriesEvaluators.fourier_contract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fourier_contract!(r::AbstractArray{T,N-1}, C::AbstractArray{T,N}, x, [k=1, a=0, shift=0, dim=Val(N)]) where {T,N}</code></pre><p>Contract dimension <code>dim</code> of array <code>C</code> and write it to the array <code>r</code>, whose axes must match <code>C</code>&#39;s (excluding dimension <code>dim</code>). This function uses the indices in <code>axes(C,N)</code> to evaluate the phase factors, which makes it compatible with <code>OffsetArray</code>s as inputs. Optionally, a <code>shift</code> can be provided to manually offset the indices. Also, <code>a</code> represents the order of derivative of the series and must be a <code>Number</code>. The formula for what this routine calculates is:</p><p class="math-container">\[r_{i_{1},\dots,i_{N-1}} = \sum_{i_{N}\in\text{axes}(C,N)} C_{i_{1},\dots,i_{N-1},i_{N}+m+1} (ik (i_{N} + \text{shift}))^{a} \exp(ik x (i_{N} + \text{shift}))\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/fourier_kernel.jl#L19-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.fourier_contract-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}, Tuple{AbstractArray{T, N}, Any, Any}, Tuple{AbstractArray{T, N}, Any, Any, Any}, Tuple{AbstractArray{T, N}, Any, Any, Any, Any}, Tuple{AbstractArray{T, N}, Any, Any, Any, Any, Any}} where {T, N}" href="#FourierSeriesEvaluators.fourier_contract-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}, Tuple{AbstractArray{T, N}, Any, Any}, Tuple{AbstractArray{T, N}, Any, Any, Any}, Tuple{AbstractArray{T, N}, Any, Any, Any, Any}, Tuple{AbstractArray{T, N}, Any, Any, Any, Any, Any}} where {T, N}"><code>FourierSeriesEvaluators.fourier_contract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fourier_contract(C::Vector, x, [k=1, a=0, shift=0, dim=Val(N)])</code></pre><p>Identical to <a href="#FourierSeriesEvaluators.fourier_contract!-Union{Tuple{dim}, Tuple{N_}, Tuple{N}, Tuple{T}, Tuple{R}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer, Val{dim}}} where {R, T, N, N_, dim}"><code>fourier_contract!</code></a> except that it allocates its output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/fourier_kernel.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.fourier_evaluate-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Integer, N}}}} where {T, N}" href="#FourierSeriesEvaluators.fourier_evaluate-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Integer, N}}}} where {T, N}"><code>FourierSeriesEvaluators.fourier_evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fourier_evaluate(C::AbstractArray{T,N}, x::NTuple{N}, [k=1, a=0, shift=0]) where {T,N}</code></pre><p>Evaluates a N-D Fourier series <code>C</code>. This function uses the indices in <code>axes(C)</code> to evaluate the phase factors, which makes it compatible with <code>OffsetArray</code>s as inputs. Optionally, a <code>shift</code> can be provided to manually offset the indices. Also, <code>a</code> represents the order of derivative of the series and must be a <code>Number</code>. The arguments <code>x, k, a, shift</code> must all be tuples of length <code>N</code>, the same as the array dimension. The 1-D formula for what this routine calculates is:</p><p class="math-container">\[r = \sum_{i_{\in\text{axes}(C,1)} C_{i} (ik (i + \text{shift}))^{a} \exp(ik x (i + \text{shift}))\]</p><div class="admonition is-info"><header class="admonition-header">Multi-dimensional performance hit</header><div class="admonition-body"><p>This routine is allocation-free, but using it for multidimensional evaluation can be slower than allocating because it always computes the Fourier coefficients on the fly. Thus, it is typically more efficient to compute the outermost dimensions of the series with <a href="#FourierSeriesEvaluators.fourier_contract!-Union{Tuple{dim}, Tuple{N_}, Tuple{N}, Tuple{T}, Tuple{R}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer}, Tuple{AbstractArray{R, N_}, AbstractArray{T, N}, Any, Any, Any, Integer, Val{dim}}} where {R, T, N, N_, dim}"><code>fourier_contract!</code></a> and then use this routine for the innermost dimension, which is faster because it doesn&#39;t use inplace operations. <a href="#FourierSeriesEvaluators.FourierSeries"><code>FourierSeries</code></a> implements this behavior.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/fourier_kernel.jl#L119-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.frequency" href="#FourierSeriesEvaluators.frequency"><code>FourierSeriesEvaluators.frequency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">frequency(f::AbstractFourierSeries, [dim]) = map(inv, period(f, [dim]))</code></pre><p>Return a tuple containing the frequency, or inverse of the period, of <code>f</code>. Optionally you can specify a dimension to just get the frequency of that dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/definitions.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.period" href="#FourierSeriesEvaluators.period"><code>FourierSeriesEvaluators.period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">period(f::AbstractFourierSeries, [dim])</code></pre><p>Return a tuple containing the periodicity of <code>f</code>. Optionally you can specify a dimension to just get the period of that dimension. This should have the floating-point precision of the input used for the Fourier series evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/definitions.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.workspace_allocate-Union{Tuple{N}, Tuple{AbstractFourierSeries{N, T, iip} where {T, iip}, Tuple{Vararg{Any, N}}}, Tuple{AbstractFourierSeries{N, T, iip} where {T, iip}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Integer, N}}}} where N" href="#FourierSeriesEvaluators.workspace_allocate-Union{Tuple{N}, Tuple{AbstractFourierSeries{N, T, iip} where {T, iip}, Tuple{Vararg{Any, N}}}, Tuple{AbstractFourierSeries{N, T, iip} where {T, iip}, Tuple{Vararg{Any, N}}, Tuple{Vararg{Integer, N}}}} where N"><code>FourierSeriesEvaluators.workspace_allocate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">workspace_allocate(s::AbstractFourierSeries{N}, x::NTuple{N}, [len::NTuple{N}=ntuple(one,N)])</code></pre><p>Allocates a <a href="#FourierSeriesEvaluators.FourierWorkspace"><code>FourierWorkspace</code></a> for the Fourier series <code>s</code> that can be used to evaluate the series multiple times without allocating on-the-fly. The <code>len</code> argument can indicate how many copies of workspace should be made for each variable for downstream use in parallel workloads.</p><p>The workspace is constructed recursively starting from the outer dimension and moving towards the inner dimension so as to access memory contiguously. Thus, the outer dimension has <code>len[N]</code> workspace copies and each of these has <code>len[N-1]</code> workspaces for the next variable. In total there are <code>prod(len)</code> leaf-level caches to use for parallel workloads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/workspace.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.workspace_contract!" href="#FourierSeriesEvaluators.workspace_contract!"><code>FourierSeriesEvaluators.workspace_contract!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">workspace_contract!(ws, x, [i=1])</code></pre><p>Returns a workspace with the series contracted at variable <code>x</code> in the outer dimension. The index <code>i</code> selects which workspace in the cache to assign the new data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/workspace.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.workspace_evaluate!" href="#FourierSeriesEvaluators.workspace_evaluate!"><code>FourierSeriesEvaluators.workspace_evaluate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">workspace_evaluate!(ws, x, [i=1])</code></pre><p>Return the 1-d series evaluated at the variable <code>x</code>, using cache sector <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/workspace.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FourierSeriesEvaluators.workspace_evaluate-Tuple{FourierWorkspace{var&quot;#s25&quot;, C} where {var&quot;#s25&quot;&lt;:(AbstractFourierSeries{1, T, iip} where {T, iip}), C}, Tuple{Any}}" href="#FourierSeriesEvaluators.workspace_evaluate-Tuple{FourierWorkspace{var&quot;#s25&quot;, C} where {var&quot;#s25&quot;&lt;:(AbstractFourierSeries{1, T, iip} where {T, iip}), C}, Tuple{Any}}"><code>FourierSeriesEvaluators.workspace_evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">workspace_evaluate(ws, x)</code></pre><p>Evaluates the series using the workspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/FourierSeriesEvaluators.jl/blob/ca12f1a1ed6ae143d8e7d6515c9f9a3419275395/src/workspace.jl#L62-L66">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 13 August 2023 17:22">Sunday 13 August 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
